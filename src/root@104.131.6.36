import java.applet.Applet;
import java.awt.*;
import java.io.IOException;
import java.net.*;
import java.nio.charset.Charset;
import java.util.HashMap;

public class ClassifierApplet extends Applet {

    private final static int UDP_RECV_BUF_SIZE = 2048;
    private final static int UDP_RECV_TIMEOUT = 10 * 1000;
    private final static int UDP_RECV_MAX_TIMEOUT = 20 * 1000;
    private final static int UDP_MAX_RETRY = 3;

    private final static String PRIMARY_IP = "52.27.15.59";
    private final static int PRIMARY_PORT1 = 2000;
    private final static int PRIMARY_PORT2 = 3000;
    private final static String SECONDARY_IP = "52.26.32.86";
    private final static int SECONDARY_PORT = 4000;

    private final static SocketAddress PRIMARY_PORT1_ADDR = new InetSocketAddress(PRIMARY_IP, PRIMARY_PORT1);
    private final static SocketAddress PRIMARY_PORT2_ADDR = new InetSocketAddress(PRIMARY_IP, PRIMARY_PORT2);
    private final static SocketAddress SECONDARY_PORT_ADDR = new InetSocketAddress(SECONDARY_IP, SECONDARY_PORT);

    enum FilterType {
        PORT, ADDRESS, NONE
    }

    enum AllocType {
        PORT, ADDRESS, NONE
    }

    private static class Result {
        FilterType filterType;
        AllocType allocType;
        int progression; // if allocType = PORT | ADDRESS
    }

    @Override
    public void paint(Graphics g) {
        determine();
    }

    public static void determine() {
        int port = 10000 + Math.round((float) Math.random() * 55000);
        try {
            HashMap<SocketAddress, Integer> responses = sendUdp(PRIMARY_IP, PRIMARY_PORT1, port);
            if (responses.size() == 0) {
                System.out.println("Connection failed for port " + port);
            }
            Result result = new Result();
            addFilterDetails(result, responses);
            System.out.println(result.filterType);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * ASSUMPTIONS: Filtered by port implies filtered by address also
     *
     * @param result
     * @param firstResponses
     * @throws IOException
     */
    public static void addFilterDetails(Result result, HashMap<SocketAddress, Integer> firstResponses) throws IOException {
        if (firstResponses.containsKey(SECONDARY_PORT_ADDR)) {
            result.filterType = FilterType.NONE;
        } else if (firstResponses.containsKey(PRIMARY_PORT2_ADDR)) {
            result.filterType = FilterType.ADDRESS;
        } else {
            result.filterType = FilterType.PORT;
        }
    }

    public static HashMap<SocketAddress, Integer> sendUdp(String toIp, int toPort, int fromPort) throws IOException {
        InetSocketAddress toAddr = new InetSocketAddress(toIp, toPort);
        DatagramSocket socket = new DatagramSocket(null);
        socket.setReuseAddress(true);
        socket.bind(new InetSocketAddress(fromPort));
        HashMap<SocketAddress, Integer> responses = new HashMap<>();
        for (int i = 0; i < UDP_MAX_RETRY; i++) {
            byte[] sendBuf = new byte[0];
            DatagramPacket packet = new DatagramPacket(sendBuf, sendBuf.length);
            packet.setSocketAddress(toAddr);
            socket.send(packet);
            responses.putAll(accumulateUniqueUdpResponses(fromPort));
            if (responses.size() != 0) break;
        }
        return responses;
    }

    public static HashMap<SocketAddress, Integer> accumulateUniqueUdpResponses(int fromPort) throws IOException {
        DatagramSocket socket = new DatagramSocket(null);
        socket.setReuseAddress(true);
        socket.bind(new InetSocketAddress(fromPort));
        byte[] recvBuf = new byte[UDP_RECV_BUF_SIZE];
        DatagramPacket packet = new DatagramPacket(recvBuf, recvBuf.length);
        socket.setSoTimeout(UDP_RECV_TIMEOUT);

        long endTime = System.currentTimeMillis() + UDP_RECV_MAX_TIMEOUT;

        HashMap<SocketAddress, Integer> responseSet = new HashMap<>();

        try {
            while (true) {
                socket.receive(packet);
                try {
                    responseSet.put(
                            packet.getSocketAddress(),
                            Integer.parseInt(
                                    new String(packet.getData(), packet.getOffset(), packet.getLength(), Charset.forName("UTF-8"))
                            )
                    );
                } catch (NumberFormatException e) {
                    // bad packet, passed checksum though
                    e.printStackTrace();
                }
                if (System.currentTimeMillis() > endTime) {
                    break;
                }
            }
        } catch (SocketTimeoutException e) {
        }

        return responseSet;
    }
}
